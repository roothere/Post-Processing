#pragma kernel CSMain

#define PI 3.14159265358979323846f

Texture2D<float4> _SobelTex, _EdgeTex;
RWTexture2D<float4> _Result;
SamplerState point_clamp_sampler;

uint _ViewUncompressed, _DebugEdges, _Grid, _EdgeThreshold;


groupshared int edgeCount[64];

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID, uint3 gid : SV_GROUPTHREADID) {
    edgeCount[gid.x + gid.y * 8] = 0;

    int grid = (gid.y == 0) + (gid.x == 0);

    float3 sobel = _SobelTex[id.xy].xyz;

    float theta = sobel.y;

    float absTheta = abs(theta) / PI;
    
    int direction = -1;
    if (any(sobel.z)) {
        if ((0.0f <= absTheta) && (absTheta < 0.05f)) direction = 0; // VERTICAL
        else if ((0.9f < absTheta) && (absTheta <= 1.0f)) direction = 0;
        else if ((0.45f < absTheta) && (absTheta < 0.55f)) direction = 1; // HORIZONTAL
        else if (0.05f < absTheta && absTheta < 0.45f) direction = sign(theta) > 0 ? 2 : 3; // DIAGONAL 1
        else if (0.55f < absTheta && absTheta < 0.9f) direction = sign(theta) > 0 ? 3 : 2; // DIAGONAL 2
    }

    edgeCount[gid.x + gid.y * 8] = direction;

    GroupMemoryBarrierWithGroupSync();

    int commonEdgeIndex = -1;
    if ((gid.x == 0) && (gid.y == 0)) {
        uint buckets[4] = {0, 0, 0, 0};

        for (int i = 0; i < 64; ++i) {
            buckets[edgeCount[i]] += 1;
        }

        uint maxValue = 0;
        for (int j = 0; j < 4; ++j) {
            if (buckets[j] > maxValue) {
                commonEdgeIndex = j;
                maxValue = buckets[j];
            }
        }

        if (maxValue < _EdgeThreshold) commonEdgeIndex = -1;

        edgeCount[0] = commonEdgeIndex;
    }

    GroupMemoryBarrierWithGroupSync();

    commonEdgeIndex = _ViewUncompressed ? direction : edgeCount[0];

    float3 debugEdge = 0;
    if (commonEdgeIndex == 0) debugEdge = float3(1, 0, 0);
    if (commonEdgeIndex == 1) debugEdge = float3(0, 1, 0);
    if (commonEdgeIndex == 2) debugEdge = float3(0, 1, 1);
    if (commonEdgeIndex == 3) debugEdge = float3(1, 1, 0);

    float4 quantizedEdge = (commonEdgeIndex + 1) * 8;

    float2 localUV;
    localUV.x = ((id.x % 8)) + quantizedEdge.x;
    localUV.y = 8 - (id.y % 8);

    float4 ascii = _EdgeTex[localUV];

    if (_ViewUncompressed) ascii = (commonEdgeIndex + 1) / 5.0f;
    if (_DebugEdges) ascii = float4(debugEdge, 1.0f);
    if (_Grid) ascii += grid;

    _Result[id.xy] = ascii;
}